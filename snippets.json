[
  {
    "name": "basic-main",
    "category": "Basic",
    "description": "Simple main function template",
    "snippet": "#include <iostream>\n\nint main() {\n    // Your code here\n    return 0;\n}"
  },
  {
    "name": "class",
    "category": "Basic",
    "description": "Basic class structure with constructor, destructor, and common methods",
    "snippet": "class ClassName {\nprivate:\n    int data;\n\npublic:\n    ClassName() : data(0) {}\n    ClassName(int val) : data(val) {}\n    ~ClassName() {}\n\n    int getData() const {\n        return data;\n    }\n\n    void setData(int val) {\n        data = val;\n    }\n\n    void display() const {\n        std::cout << \"Data: \" << data << std::endl;\n    }\n};"
  },
  {
    "name": "header-guard",
    "category": "Basic",
    "description": "Include guard pattern for header files",
    "snippet": "#ifndef FILENAME_H\n#define FILENAME_H\n\n// Your header content here\n\n#endif // FILENAME_H"
  },
  {
    "name": "fast-io",
    "category": "I/O",
    "description": "Fast input/output optimization for competitive programming",
    "snippet": "#include <iostream>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    // Your code here\n\n    return 0;\n}"
  },
  {
    "name": "file-io",
    "category": "I/O",
    "description": "File reading and writing template",
    "snippet": "#include <fstream>\n#include <iostream>\n#include <string>\n\nint main() {\n    // Reading from file\n    std::ifstream inputFile(\"input.txt\");\n    if (!inputFile.is_open()) {\n        std::cerr << \"Error opening input file\" << std::endl;\n        return 1;\n    }\n\n    std::string line;\n    while (std::getline(inputFile, line)) {\n        // Process line\n        std::cout << line << std::endl;\n    }\n    inputFile.close();\n\n    // Writing to file\n    std::ofstream outputFile(\"output.txt\");\n    if (!outputFile.is_open()) {\n        std::cerr << \"Error opening output file\" << std::endl;\n        return 1;\n    }\n\n    outputFile << \"Hello, File!\" << std::endl;\n    outputFile.close();\n\n    return 0;\n}"
  },
  {
    "name": "string-stream",
    "category": "I/O",
    "description": "String parsing with stringstream",
    "snippet": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\nint main() {\n    std::string str = \"10 20 30 40 50\";\n    std::stringstream ss(str);\n\n    std::vector<int> numbers;\n    int num;\n    while (ss >> num) {\n        numbers.push_back(num);\n    }\n\n    // Process numbers\n    for (int n : numbers) {\n        std::cout << n << \" \";\n    }\n    std::cout << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "vector-ops",
    "category": "Data Structures",
    "description": "Common vector initialization and operations",
    "snippet": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nint main() {\n    // Initialization\n    std::vector<int> v1;                    // Empty vector\n    std::vector<int> v2(10);                // 10 elements, default value 0\n    std::vector<int> v3(10, 5);             // 10 elements, all 5\n    std::vector<int> v4 = {1, 2, 3, 4, 5};  // Initializer list\n\n    // Operations\n    v1.push_back(10);\n    v1.pop_back();\n    v1.insert(v1.begin(), 5);\n    v1.erase(v1.begin());\n\n    // Access\n    int front = v4.front();\n    int back = v4.back();\n    int at_index = v4[2];\n\n    // Size operations\n    size_t size = v4.size();\n    bool empty = v4.empty();\n    v4.clear();\n\n    // Sorting\n    std::sort(v4.begin(), v4.end());\n    std::reverse(v4.begin(), v4.end());\n\n    return 0;\n}"
  },
  {
    "name": "map-set",
    "category": "Data Structures",
    "description": "STL map and set examples",
    "snippet": "#include <map>\n#include <set>\n#include <iostream>\n\nint main() {\n    // Map operations\n    std::map<std::string, int> m;\n    m[\"apple\"] = 5;\n    m[\"banana\"] = 3;\n    m.insert({\"orange\", 7});\n\n    // Check existence\n    if (m.find(\"apple\") != m.end()) {\n        std::cout << \"Found apple: \" << m[\"apple\"] << std::endl;\n    }\n\n    // Iterate\n    for (const auto& [key, value] : m) {\n        std::cout << key << \": \" << value << std::endl;\n    }\n\n    // Set operations\n    std::set<int> s = {1, 2, 3, 4, 5};\n    s.insert(6);\n    s.erase(3);\n\n    // Check existence\n    if (s.count(4) > 0) {\n        std::cout << \"4 is in the set\" << std::endl;\n    }\n\n    return 0;\n}"
  },
  {
    "name": "priority-queue",
    "category": "Data Structures",
    "description": "Min/max heap implementations using priority_queue",
    "snippet": "#include <queue>\n#include <vector>\n#include <iostream>\n\nint main() {\n    // Max heap (default)\n    std::priority_queue<int> maxHeap;\n    maxHeap.push(10);\n    maxHeap.push(5);\n    maxHeap.push(20);\n\n    std::cout << \"Max: \" << maxHeap.top() << std::endl; // 20\n    maxHeap.pop();\n\n    // Min heap\n    std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;\n    minHeap.push(10);\n    minHeap.push(5);\n    minHeap.push(20);\n\n    std::cout << \"Min: \" << minHeap.top() << std::endl; // 5\n    minHeap.pop();\n\n    return 0;\n}"
  },
  {
    "name": "pair-tuple",
    "category": "Data Structures",
    "description": "Using pairs and tuples in C++",
    "snippet": "#include <utility>\n#include <tuple>\n#include <iostream>\n\nint main() {\n    // Pair\n    std::pair<int, std::string> p1 = {1, \"one\"};\n    std::pair<int, std::string> p2 = std::make_pair(2, \"two\");\n\n    std::cout << p1.first << \" \" << p1.second << std::endl;\n\n    // Structured binding (C++17)\n    auto [num, str] = p1;\n    std::cout << num << \" \" << str << std::endl;\n\n    // Tuple\n    std::tuple<int, double, std::string> t = {1, 3.14, \"pi\"};\n\n    std::cout << std::get<0>(t) << \" \";\n    std::cout << std::get<1>(t) << \" \";\n    std::cout << std::get<2>(t) << std::endl;\n\n    // Structured binding with tuple\n    auto [i, d, s] = t;\n    std::cout << i << \" \" << d << \" \" << s << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "binary-search",
    "category": "Algorithms",
    "description": "Binary search implementation",
    "snippet": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\n// Manual binary search\nint binarySearch(const std::vector<int>& arr, int target) {\n    int left = 0;\n    int right = arr.size() - 1;\n\n    while (left <= right) {\n        int mid = left + (right - left) / 2;\n\n        if (arr[mid] == target) {\n            return mid;\n        } else if (arr[mid] < target) {\n            left = mid + 1;\n        } else {\n            right = mid - 1;\n        }\n    }\n\n    return -1; // Not found\n}\n\nint main() {\n    std::vector<int> arr = {1, 3, 5, 7, 9, 11, 13};\n\n    // Manual implementation\n    int index = binarySearch(arr, 7);\n    std::cout << \"Index: \" << index << std::endl;\n\n    // STL binary_search (returns bool)\n    bool found = std::binary_search(arr.begin(), arr.end(), 7);\n    std::cout << \"Found: \" << found << std::endl;\n\n    // STL lower_bound (returns iterator)\n    auto it = std::lower_bound(arr.begin(), arr.end(), 7);\n    if (it != arr.end()) {\n        std::cout << \"Lower bound index: \" << (it - arr.begin()) << std::endl;\n    }\n\n    return 0;\n}"
  },
  {
    "name": "dfs",
    "category": "Algorithms",
    "description": "Depth-first search for graphs and grids",
    "snippet": "#include <vector>\n#include <iostream>\n\n// Graph DFS (Adjacency List)\nstd::vector<std::vector<int>> adj;\nstd::vector<bool> visited;\n\nvoid dfs_graph(int node) {\n    visited[node] = true;\n    std::cout << node << \" \";\n\n    for (int neighbor : adj[node]) {\n        if (!visited[neighbor]) {\n            dfs_graph(neighbor);\n        }\n    }\n}\n\n// Grid/Matrix DFS\nint dx[] = {-1, 1, 0, 0}; // Up, Down, Left, Right\nint dy[] = {0, 0, -1, 1};\n\nvoid dfs_grid(std::vector<std::vector<int>>& grid, int x, int y) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    if (x < 0 || x >= rows || y < 0 || y >= cols || grid[x][y] == 0) {\n        return;\n    }\n\n    grid[x][y] = 0; // Mark as visited\n\n    for (int i = 0; i < 4; i++) {\n        dfs_grid(grid, x + dx[i], y + dy[i]);\n    }\n}\n\nint main() {\n    // Example 1: Graph DFS\n    int n = 6;\n    adj.resize(n);\n    visited.resize(n, false);\n\n    adj[0] = {1, 2};\n    adj[1] = {0, 3, 4};\n    adj[2] = {0, 5};\n\n    std::cout << \"Graph DFS: \";\n    dfs_graph(0);\n    std::cout << std::endl;\n\n    // Example 2: Grid DFS (find connected components)\n    std::vector<std::vector<int>> grid = {\n        {1, 1, 0, 0, 0},\n        {1, 1, 0, 0, 1},\n        {0, 0, 1, 0, 0},\n        {0, 0, 0, 1, 1}\n    };\n\n    dfs_grid(grid, 0, 0); // Visit island starting at (0,0)\n\n    return 0;\n}"
  },
  {
    "name": "bfs",
    "category": "Algorithms",
    "description": "Breadth-first search for graphs and grids",
    "snippet": "#include <vector>\n#include <queue>\n#include <iostream>\n\n// Graph BFS (Adjacency List)\nstd::vector<std::vector<int>> adj;\nstd::vector<bool> visited;\n\nvoid bfs_graph(int start) {\n    std::queue<int> q;\n    q.push(start);\n    visited[start] = true;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        std::cout << node << \" \";\n\n        for (int neighbor : adj[node]) {\n            if (!visited[neighbor]) {\n                visited[neighbor] = true;\n                q.push(neighbor);\n            }\n        }\n    }\n}\n\n// Grid/Matrix BFS\nint dx[] = {-1, 1, 0, 0}; // Up, Down, Left, Right\nint dy[] = {0, 0, -1, 1};\n\nint bfs_grid(std::vector<std::vector<int>>& grid, int startX, int startY) {\n    int rows = grid.size();\n    int cols = grid[0].size();\n\n    if (grid[startX][startY] == 0) return 0;\n\n    std::queue<std::pair<int, int>> q;\n    q.push({startX, startY});\n    grid[startX][startY] = 0; // Mark as visited\n\n    int count = 0;\n    while (!q.empty()) {\n        auto [x, y] = q.front();\n        q.pop();\n        count++;\n\n        for (int i = 0; i < 4; i++) {\n            int nx = x + dx[i];\n            int ny = y + dy[i];\n\n            if (nx >= 0 && nx < rows && ny >= 0 && ny < cols && grid[nx][ny] == 1) {\n                grid[nx][ny] = 0; // Mark as visited\n                q.push({nx, ny});\n            }\n        }\n    }\n    return count;\n}\n\nint main() {\n    // Example 1: Graph BFS\n    int n = 6;\n    adj.resize(n);\n    visited.resize(n, false);\n\n    adj[0] = {1, 2};\n    adj[1] = {0, 3, 4};\n    adj[2] = {0, 5};\n\n    std::cout << \"Graph BFS: \";\n    bfs_graph(0);\n    std::cout << std::endl;\n\n    // Example 2: Grid BFS (count island size)\n    std::vector<std::vector<int>> grid = {\n        {1, 1, 0, 0, 0},\n        {1, 1, 0, 0, 1},\n        {0, 0, 1, 0, 0},\n        {0, 0, 0, 1, 1}\n    };\n\n    int island_size = bfs_grid(grid, 0, 0);\n    std::cout << \"Island size: \" << island_size << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "sorting-custom",
    "category": "Algorithms",
    "description": "Custom comparator for sorting",
    "snippet": "#include <vector>\n#include <algorithm>\n#include <iostream>\n\nstruct Person {\n    std::string name;\n    int age;\n};\n\n// Comparator function\nbool compareByAge(const Person& a, const Person& b) {\n    return a.age < b.age;\n}\n\nint main() {\n    std::vector<Person> people = {\n        {\"Alice\", 30},\n        {\"Bob\", 25},\n        {\"Charlie\", 35}\n    };\n\n    // Using function\n    std::sort(people.begin(), people.end(), compareByAge);\n\n    // Using lambda\n    std::sort(people.begin(), people.end(), [](const Person& a, const Person& b) {\n        return a.name < b.name;\n    });\n\n    // Sorting pairs by second element\n    std::vector<std::pair<int, int>> pairs = {{1, 5}, {2, 3}, {3, 8}};\n    std::sort(pairs.begin(), pairs.end(), [](const auto& a, const auto& b) {\n        return a.second < b.second;\n    });\n\n    // Print results\n    for (const auto& p : people) {\n        std::cout << p.name << \" (\" << p.age << \")\" << std::endl;\n    }\n\n    return 0;\n}"
  },
  {
    "name": "lambda-functions",
    "category": "Modern C++",
    "description": "Lambda syntax and usage examples",
    "snippet": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <functional>\n\nint main() {\n    // Basic lambda\n    auto add = [](int a, int b) { return a + b; };\n    std::cout << add(3, 4) << std::endl;\n\n    // Lambda with capture\n    int multiplier = 3;\n    auto multiply = [multiplier](int x) { return x * multiplier; };\n    std::cout << multiply(5) << std::endl;\n\n    // Capture by reference\n    int counter = 0;\n    auto increment = [&counter]() { counter++; };\n    increment();\n    increment();\n    std::cout << \"Counter: \" << counter << std::endl;\n\n    // Generic lambda (C++14)\n    auto print = [](const auto& val) { std::cout << val << std::endl; };\n    print(42);\n    print(\"Hello\");\n\n    // Lambda with algorithms\n    std::vector<int> v = {1, 2, 3, 4, 5};\n    std::for_each(v.begin(), v.end(), [](int x) {\n        std::cout << x * 2 << \" \";\n    });\n    std::cout << std::endl;\n\n    // Lambda as return type\n    auto makeAdder = [](int n) {\n        return [n](int x) { return x + n; };\n    };\n    auto add10 = makeAdder(10);\n    std::cout << add10(5) << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "range-for",
    "category": "Modern C++",
    "description": "Modern C++ range-based iteration patterns",
    "snippet": "#include <vector>\n#include <map>\n#include <iostream>\n\nint main() {\n    // Vector iteration\n    std::vector<int> v = {1, 2, 3, 4, 5};\n\n    // Read-only\n    for (const auto& elem : v) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n\n    // Modify elements\n    for (auto& elem : v) {\n        elem *= 2;\n    }\n\n    // Copy (less efficient)\n    for (auto elem : v) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n\n    // Map iteration with structured binding\n    std::map<std::string, int> m = {\n        {\"apple\", 5},\n        {\"banana\", 3},\n        {\"orange\", 7}\n    };\n\n    for (const auto& [key, value] : m) {\n        std::cout << key << \": \" << value << std::endl;\n    }\n\n    // Traditional iterator when index is needed\n    for (size_t i = 0; i < v.size(); ++i) {\n        std::cout << \"v[\" << i << \"] = \" << v[i] << std::endl;\n    }\n\n    return 0;\n}"
  },
  {
    "name": "smart-pointers",
    "category": "Modern C++",
    "description": "Modern C++ smart pointer usage (unique_ptr, shared_ptr)",
    "snippet": "#include <memory>\n#include <iostream>\n#include <vector>\n\nclass MyClass {\npublic:\n    MyClass(int val) : value(val) {\n        std::cout << \"Constructor: \" << value << std::endl;\n    }\n    ~MyClass() {\n        std::cout << \"Destructor: \" << value << std::endl;\n    }\n    void display() {\n        std::cout << \"Value: \" << value << std::endl;\n    }\nprivate:\n    int value;\n};\n\nint main() {\n    // unique_ptr - exclusive ownership\n    std::unique_ptr<MyClass> ptr1 = std::make_unique<MyClass>(10);\n    ptr1->display();\n\n    // Transfer ownership\n    std::unique_ptr<MyClass> ptr2 = std::move(ptr1);\n    // ptr1 is now nullptr\n\n    // shared_ptr - shared ownership\n    std::shared_ptr<MyClass> sptr1 = std::make_shared<MyClass>(20);\n    {\n        std::shared_ptr<MyClass> sptr2 = sptr1; // Reference count = 2\n        sptr2->display();\n        std::cout << \"Use count: \" << sptr1.use_count() << std::endl;\n    } // sptr2 destroyed, reference count = 1\n\n    std::cout << \"Use count: \" << sptr1.use_count() << std::endl;\n\n    // weak_ptr - non-owning reference\n    std::weak_ptr<MyClass> wptr = sptr1;\n    if (auto locked = wptr.lock()) {\n        locked->display();\n    }\n\n    // Vector of unique_ptrs\n    std::vector<std::unique_ptr<MyClass>> vec;\n    vec.push_back(std::make_unique<MyClass>(30));\n    vec.push_back(std::make_unique<MyClass>(40));\n\n    return 0;\n}"
  },
  {
    "name": "template-function",
    "category": "Modern C++",
    "description": "Generic function template examples",
    "snippet": "#include <iostream>\n#include <vector>\n#include <string>\n\n// Basic template function\ntemplate<typename T>\nT maximum(T a, T b) {\n    return (a > b) ? a : b;\n}\n\n// Template with multiple type parameters\ntemplate<typename T, typename U>\nauto add(T a, U b) -> decltype(a + b) {\n    return a + b;\n}\n\n// Template function with container\ntemplate<typename T>\nvoid printVector(const std::vector<T>& vec) {\n    for (const auto& elem : vec) {\n        std::cout << elem << \" \";\n    }\n    std::cout << std::endl;\n}\n\n// Template with constraints (concept-like, C++20 style)\ntemplate<typename T>\nT sumVector(const std::vector<T>& vec) {\n    T sum = T();\n    for (const auto& elem : vec) {\n        sum += elem;\n    }\n    return sum;\n}\n\n// Template class\ntemplate<typename T>\nclass Container {\nprivate:\n    T value;\npublic:\n    Container(T val) : value(val) {}\n    T getValue() const { return value; }\n    void setValue(T val) { value = val; }\n};\n\nint main() {\n    std::cout << maximum(10, 20) << std::endl;\n    std::cout << maximum(3.14, 2.71) << std::endl;\n    std::cout << maximum<std::string>(\"apple\", \"banana\") << std::endl;\n\n    std::cout << add(5, 3.14) << std::endl;\n\n    std::vector<int> v1 = {1, 2, 3, 4, 5};\n    printVector(v1);\n\n    std::vector<std::string> v2 = {\"hello\", \"world\"};\n    printVector(v2);\n\n    Container<int> c1(42);\n    std::cout << c1.getValue() << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "mod-arithmetic",
    "category": "Competitive Programming",
    "description": "Modular arithmetic helpers for competitive programming",
    "snippet": "#include <iostream>\n\nconst long long MOD = 1e9 + 7;\n\n// Modular addition\nlong long addMod(long long a, long long b, long long mod = MOD) {\n    return ((a % mod) + (b % mod)) % mod;\n}\n\n// Modular subtraction\nlong long subMod(long long a, long long b, long long mod = MOD) {\n    return ((a % mod) - (b % mod) + mod) % mod;\n}\n\n// Modular multiplication\nlong long mulMod(long long a, long long b, long long mod = MOD) {\n    return ((a % mod) * (b % mod)) % mod;\n}\n\n// Modular exponentiation (fast power)\nlong long powerMod(long long base, long long exp, long long mod = MOD) {\n    long long result = 1;\n    base %= mod;\n    while (exp > 0) {\n        if (exp % 2 == 1) {\n            result = (result * base) % mod;\n        }\n        base = (base * base) % mod;\n        exp /= 2;\n    }\n    return result;\n}\n\n// Modular inverse using Fermat's little theorem (when mod is prime)\nlong long modInverse(long long a, long long mod = MOD) {\n    return powerMod(a, mod - 2, mod);\n}\n\n// Modular division\nlong long divMod(long long a, long long b, long long mod = MOD) {\n    return mulMod(a, modInverse(b, mod), mod);\n}\n\nint main() {\n    long long a = 1000000000;\n    long long b = 999999999;\n\n    std::cout << \"Add: \" << addMod(a, b) << std::endl;\n    std::cout << \"Mul: \" << mulMod(a, b) << std::endl;\n    std::cout << \"Power: \" << powerMod(2, 10) << std::endl;\n    std::cout << \"Inverse: \" << modInverse(3) << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "gcd-lcm",
    "category": "Competitive Programming",
    "description": "Greatest common divisor and least common multiple",
    "snippet": "#include <iostream>\n#include <numeric> // For std::gcd and std::lcm (C++17)\n#include <algorithm>\n\n// Manual GCD implementation (Euclidean algorithm)\nlong long gcd(long long a, long long b) {\n    while (b != 0) {\n        long long temp = b;\n        b = a % b;\n        a = temp;\n    }\n    return a;\n}\n\n// Manual LCM implementation\nlong long lcm(long long a, long long b) {\n    return (a / gcd(a, b)) * b;\n}\n\n// Extended Euclidean Algorithm\n// Finds gcd(a, b) and coefficients x, y such that ax + by = gcd(a, b)\nlong long extendedGCD(long long a, long long b, long long& x, long long& y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long x1, y1;\n    long long gcd = extendedGCD(b, a % b, x1, y1);\n    x = y1;\n    y = x1 - (a / b) * y1;\n    return gcd;\n}\n\nint main() {\n    long long a = 48, b = 18;\n\n    // Using manual implementation\n    std::cout << \"GCD(\" << a << \", \" << b << \") = \" << gcd(a, b) << std::endl;\n    std::cout << \"LCM(\" << a << \", \" << b << \") = \" << lcm(a, b) << std::endl;\n\n    // Using C++17 STL\n    std::cout << \"STL GCD: \" << std::gcd(a, b) << std::endl;\n    std::cout << \"STL LCM: \" << std::lcm(a, b) << std::endl;\n\n    // Extended GCD\n    long long x, y;\n    long long g = extendedGCD(a, b, x, y);\n    std::cout << \"Extended GCD: \" << g << std::endl;\n    std::cout << a << \"*\" << x << \" + \" << b << \"*\" << y << \" = \" << g << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "sliding-window",
    "category": "Common Patterns",
    "description": "Sliding window technique template for subarray problems",
    "snippet": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\n\n// Fixed size sliding window\nint maxSumFixedWindow(const std::vector<int>& arr, int k) {\n    int n = arr.size();\n    if (n < k) return -1;\n\n    int windowSum = 0;\n    for (int i = 0; i < k; i++) {\n        windowSum += arr[i];\n    }\n\n    int maxSum = windowSum;\n    for (int i = k; i < n; i++) {\n        windowSum += arr[i] - arr[i - k];\n        maxSum = std::max(maxSum, windowSum);\n    }\n\n    return maxSum;\n}\n\n// Variable size sliding window - longest substring with at most k distinct chars\nint longestSubstringKDistinct(const std::string& s, int k) {\n    std::unordered_map<char, int> freq;\n    int left = 0, maxLen = 0;\n\n    for (int right = 0; right < s.length(); right++) {\n        freq[s[right]]++;\n\n        // Shrink window if constraint violated\n        while (freq.size() > k) {\n            freq[s[left]]--;\n            if (freq[s[left]] == 0) {\n                freq.erase(s[left]);\n            }\n            left++;\n        }\n\n        maxLen = std::max(maxLen, right - left + 1);\n    }\n\n    return maxLen;\n}\n\nint main() {\n    std::vector<int> arr = {1, 4, 2, 10, 23, 3, 1, 0, 20};\n    std::cout << \"Max sum of window size 4: \" << maxSumFixedWindow(arr, 4) << std::endl;\n\n    std::string s = \"aabbcc\";\n    std::cout << \"Longest substring with 2 distinct: \" << longestSubstringKDistinct(s, 2) << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "two-pointers",
    "category": "Common Patterns",
    "description": "Two pointers pattern for array problems",
    "snippet": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\n// Two sum in sorted array\nstd::pair<int, int> twoSumSorted(const std::vector<int>& arr, int target) {\n    int left = 0, right = arr.size() - 1;\n\n    while (left < right) {\n        int sum = arr[left] + arr[right];\n        if (sum == target) {\n            return {left, right};\n        } else if (sum < target) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n\n    return {-1, -1};\n}\n\n// Remove duplicates from sorted array (in-place)\nint removeDuplicates(std::vector<int>& arr) {\n    if (arr.empty()) return 0;\n\n    int writePos = 1;\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] != arr[i - 1]) {\n            arr[writePos++] = arr[i];\n        }\n    }\n\n    return writePos;\n}\n\n// Container with most water\nint maxArea(const std::vector<int>& height) {\n    int left = 0, right = height.size() - 1;\n    int maxWater = 0;\n\n    while (left < right) {\n        int width = right - left;\n        int h = std::min(height[left], height[right]);\n        maxWater = std::max(maxWater, width * h);\n\n        // Move pointer with smaller height\n        if (height[left] < height[right]) {\n            left++;\n        } else {\n            right--;\n        }\n    }\n\n    return maxWater;\n}\n\nint main() {\n    std::vector<int> sorted = {1, 2, 3, 4, 6};\n    auto [i, j] = twoSumSorted(sorted, 6);\n    std::cout << \"Two sum indices: \" << i << \", \" << j << std::endl;\n\n    std::vector<int> dups = {1, 1, 2, 2, 3, 3, 4};\n    int newLen = removeDuplicates(dups);\n    std::cout << \"New length after removing duplicates: \" << newLen << std::endl;\n\n    std::vector<int> heights = {1, 8, 6, 2, 5, 4, 8, 3, 7};\n    std::cout << \"Max water: \" << maxArea(heights) << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "backtracking",
    "category": "Common Patterns",
    "description": "Backtracking template with pruning for combinatorial problems",
    "snippet": "#include <iostream>\n#include <vector>\n\nstd::vector<std::vector<int>> result;\n\n// Generate all permutations\nvoid permuteBacktrack(std::vector<int>& nums, int start) {\n    if (start == nums.size()) {\n        result.push_back(nums);\n        return;\n    }\n\n    for (int i = start; i < nums.size(); i++) {\n        std::swap(nums[start], nums[i]);\n        permuteBacktrack(nums, start + 1);\n        std::swap(nums[start], nums[i]); // Backtrack\n    }\n}\n\n// Generate all subsets\nvoid subsetsBacktrack(const std::vector<int>& nums, int index,\n                      std::vector<int>& current, std::vector<std::vector<int>>& result) {\n    result.push_back(current);\n\n    for (int i = index; i < nums.size(); i++) {\n        current.push_back(nums[i]);\n        subsetsBacktrack(nums, i + 1, current, result);\n        current.pop_back(); // Backtrack\n    }\n}\n\n// N-Queens with pruning\nbool isSafe(const std::vector<std::string>& board, int row, int col, int n) {\n    // Check column\n    for (int i = 0; i < row; i++) {\n        if (board[i][col] == 'Q') return false;\n    }\n\n    // Check diagonal\n    for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n        if (board[i][j] == 'Q') return false;\n    }\n\n    // Check anti-diagonal\n    for (int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++) {\n        if (board[i][j] == 'Q') return false;\n    }\n\n    return true;\n}\n\nvoid solveNQueens(int n, int row, std::vector<std::string>& board,\n                  std::vector<std::vector<std::string>>& solutions) {\n    if (row == n) {\n        solutions.push_back(board);\n        return;\n    }\n\n    for (int col = 0; col < n; col++) {\n        if (isSafe(board, row, col, n)) {\n            board[row][col] = 'Q';\n            solveNQueens(n, row + 1, board, solutions);\n            board[row][col] = '.'; // Backtrack\n        }\n    }\n}\n\nint main() {\n    // Permutations\n    std::vector<int> nums = {1, 2, 3};\n    permuteBacktrack(nums, 0);\n    std::cout << \"Permutations: \" << result.size() << std::endl;\n\n    // Subsets\n    result.clear();\n    std::vector<int> current;\n    subsetsBacktrack(nums, 0, current, result);\n    std::cout << \"Subsets: \" << result.size() << std::endl;\n\n    // N-Queens\n    int n = 4;\n    std::vector<std::vector<std::string>> solutions;\n    std::vector<std::string> board(n, std::string(n, '.'));\n    solveNQueens(n, 0, board, solutions);\n    std::cout << n << \"-Queens solutions: \" << solutions.size() << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "monotonic-stack",
    "category": "Common Patterns",
    "description": "Monotonic stack for next greater/smaller element problems",
    "snippet": "#include <iostream>\n#include <vector>\n#include <stack>\n\n// Next greater element to the right\nstd::vector<int> nextGreaterElement(const std::vector<int>& arr) {\n    int n = arr.size();\n    std::vector<int> result(n, -1);\n    std::stack<int> s; // Stack stores indices\n\n    for (int i = 0; i < n; i++) {\n        // Maintain decreasing monotonic stack\n        while (!s.empty() && arr[s.top()] < arr[i]) {\n            result[s.top()] = arr[i];\n            s.pop();\n        }\n        s.push(i);\n    }\n\n    return result;\n}\n\n// Next smaller element to the left\nstd::vector<int> nextSmallerLeft(const std::vector<int>& arr) {\n    int n = arr.size();\n    std::vector<int> result(n, -1);\n    std::stack<int> s;\n\n    for (int i = 0; i < n; i++) {\n        // Maintain increasing monotonic stack\n        while (!s.empty() && arr[s.top()] >= arr[i]) {\n            s.pop();\n        }\n        if (!s.empty()) {\n            result[i] = arr[s.top()];\n        }\n        s.push(i);\n    }\n\n    return result;\n}\n\n// Largest rectangle in histogram\nint largestRectangleArea(const std::vector<int>& heights) {\n    std::stack<int> s;\n    int maxArea = 0;\n    int n = heights.size();\n\n    for (int i = 0; i < n; i++) {\n        while (!s.empty() && heights[s.top()] > heights[i]) {\n            int h = heights[s.top()];\n            s.pop();\n            int width = s.empty() ? i : i - s.top() - 1;\n            maxArea = std::max(maxArea, h * width);\n        }\n        s.push(i);\n    }\n\n    while (!s.empty()) {\n        int h = heights[s.top()];\n        s.pop();\n        int width = s.empty() ? n : n - s.top() - 1;\n        maxArea = std::max(maxArea, h * width);\n    }\n\n    return maxArea;\n}\n\n// Daily temperatures - how many days until warmer\nstd::vector<int> dailyTemperatures(const std::vector<int>& temps) {\n    int n = temps.size();\n    std::vector<int> result(n, 0);\n    std::stack<int> s;\n\n    for (int i = 0; i < n; i++) {\n        while (!s.empty() && temps[s.top()] < temps[i]) {\n            int idx = s.top();\n            s.pop();\n            result[idx] = i - idx;\n        }\n        s.push(i);\n    }\n\n    return result;\n}\n\nint main() {\n    std::vector<int> arr = {4, 5, 2, 10, 8};\n\n    auto nge = nextGreaterElement(arr);\n    std::cout << \"Next greater elements: \";\n    for (int x : nge) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    std::vector<int> heights = {2, 1, 5, 6, 2, 3};\n    std::cout << \"Largest rectangle area: \" << largestRectangleArea(heights) << std::endl;\n\n    std::vector<int> temps = {73, 74, 75, 71, 69, 72, 76, 73};\n    auto days = dailyTemperatures(temps);\n    std::cout << \"Days until warmer: \";\n    for (int d : days) std::cout << d << \" \";\n    std::cout << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "prefix-sum",
    "category": "Common Patterns",
    "description": "Prefix sum and difference array techniques",
    "snippet": "#include <iostream>\n#include <vector>\n\n// Basic prefix sum\nclass PrefixSum {\nprivate:\n    std::vector<long long> prefix;\n\npublic:\n    PrefixSum(const std::vector<int>& arr) {\n        int n = arr.size();\n        prefix.resize(n + 1, 0);\n        for (int i = 0; i < n; i++) {\n            prefix[i + 1] = prefix[i] + arr[i];\n        }\n    }\n\n    // Sum of range [left, right] (0-indexed)\n    long long rangeSum(int left, int right) {\n        return prefix[right + 1] - prefix[left];\n    }\n};\n\n// 2D prefix sum\nclass PrefixSum2D {\nprivate:\n    std::vector<std::vector<long long>> prefix;\n\npublic:\n    PrefixSum2D(const std::vector<std::vector<int>>& matrix) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n        prefix.resize(m + 1, std::vector<long long>(n + 1, 0));\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                prefix[i][j] = matrix[i-1][j-1]\n                             + prefix[i-1][j]\n                             + prefix[i][j-1]\n                             - prefix[i-1][j-1];\n            }\n        }\n    }\n\n    // Sum of submatrix from (r1,c1) to (r2,c2) (0-indexed)\n    long long rangeSum(int r1, int c1, int r2, int c2) {\n        r1++; c1++; r2++; c2++;\n        return prefix[r2][c2]\n             - prefix[r1-1][c2]\n             - prefix[r2][c1-1]\n             + prefix[r1-1][c1-1];\n    }\n};\n\n// Difference array for range updates\nclass DifferenceArray {\nprivate:\n    std::vector<long long> diff;\n\npublic:\n    DifferenceArray(int n) : diff(n + 1, 0) {}\n\n    // Add val to range [left, right]\n    void rangeAdd(int left, int right, int val) {\n        diff[left] += val;\n        diff[right + 1] -= val;\n    }\n\n    // Get final array after all updates\n    std::vector<long long> getFinalArray() {\n        std::vector<long long> result;\n        long long sum = 0;\n        for (int i = 0; i < diff.size() - 1; i++) {\n            sum += diff[i];\n            result.push_back(sum);\n        }\n        return result;\n    }\n};\n\nint main() {\n    // 1D prefix sum\n    std::vector<int> arr = {1, 2, 3, 4, 5};\n    PrefixSum ps(arr);\n    std::cout << \"Sum [1, 3]: \" << ps.rangeSum(1, 3) << std::endl;\n\n    // 2D prefix sum\n    std::vector<std::vector<int>> matrix = {\n        {1, 2, 3},\n        {4, 5, 6},\n        {7, 8, 9}\n    };\n    PrefixSum2D ps2d(matrix);\n    std::cout << \"2D sum [(0,0) to (1,1)]: \" << ps2d.rangeSum(0, 0, 1, 1) << std::endl;\n\n    // Difference array\n    DifferenceArray diff(5);\n    diff.rangeAdd(0, 2, 10);\n    diff.rangeAdd(1, 4, 5);\n    auto result = diff.getFinalArray();\n    std::cout << \"After range updates: \";\n    for (long long x : result) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "stl-find",
    "category": "STL",
    "description": "std::find and std::find_if for searching in containers",
    "snippet": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n\n    // std::find - search for value\n    auto it = std::find(v.begin(), v.end(), 5);\n    if (it != v.end()) {\n        std::cout << \"Found: \" << *it << \" at position \" << (it - v.begin()) << std::endl;\n    }\n\n    // std::find_if - search with predicate\n    auto even = std::find_if(v.begin(), v.end(), [](int x) { return x % 2 == 0; });\n    if (even != v.end()) {\n        std::cout << \"First even: \" << *even << std::endl;\n    }\n\n    // std::find_if_not - search for element not matching predicate\n    auto not_small = std::find_if_not(v.begin(), v.end(), [](int x) { return x < 5; });\n    if (not_small != v.end()) {\n        std::cout << \"First not small: \" << *not_small << std::endl;\n    }\n\n    // Check if element exists\n    bool has_seven = std::find(v.begin(), v.end(), 7) != v.end();\n    std::cout << \"Has 7: \" << (has_seven ? \"yes\" : \"no\") << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "stl-count",
    "category": "STL",
    "description": "std::count and std::count_if for counting elements",
    "snippet": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nint main() {\n    std::vector<int> v = {1, 2, 3, 2, 4, 2, 5, 2};\n\n    // std::count - count occurrences of value\n    int count_twos = std::count(v.begin(), v.end(), 2);\n    std::cout << \"Number of 2s: \" << count_twos << std::endl;\n\n    // std::count_if - count with predicate\n    int count_even = std::count_if(v.begin(), v.end(), [](int x) { return x % 2 == 0; });\n    std::cout << \"Even numbers: \" << count_even << std::endl;\n\n    // Count in strings\n    std::string str = \"hello world\";\n    int count_l = std::count(str.begin(), str.end(), 'l');\n    std::cout << \"Letter 'l' count: \" << count_l << std::endl;\n\n    // Count with complex predicate\n    int count_large = std::count_if(v.begin(), v.end(), [](int x) { return x > 3; });\n    std::cout << \"Numbers > 3: \" << count_large << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "stl-accumulate",
    "category": "STL",
    "description": "std::accumulate for sum, product, and custom operations",
    "snippet": "#include <iostream>\n#include <vector>\n#include <numeric>\n#include <string>\n\nint main() {\n    std::vector<int> v = {1, 2, 3, 4, 5};\n\n    // Sum of elements\n    int sum = std::accumulate(v.begin(), v.end(), 0);\n    std::cout << \"Sum: \" << sum << std::endl;\n\n    // Product of elements\n    int product = std::accumulate(v.begin(), v.end(), 1, std::multiplies<int>());\n    std::cout << \"Product: \" << product << std::endl;\n\n    // Custom operation with lambda\n    int sum_of_squares = std::accumulate(v.begin(), v.end(), 0,\n        [](int acc, int x) { return acc + x * x; });\n    std::cout << \"Sum of squares: \" << sum_of_squares << std::endl;\n\n    // Concatenate strings\n    std::vector<std::string> words = {\"Hello\", \" \", \"World\", \"!\"};\n    std::string sentence = std::accumulate(words.begin(), words.end(), std::string(\"\"));\n    std::cout << \"Sentence: \" << sentence << std::endl;\n\n    // Count elements matching condition\n    int count_even = std::accumulate(v.begin(), v.end(), 0,\n        [](int acc, int x) { return acc + (x % 2 == 0 ? 1 : 0); });\n    std::cout << \"Even count: \" << count_even << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "stl-transform",
    "category": "STL",
    "description": "std::transform to apply function to range",
    "snippet": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cctype>\n#include <string>\n\nint main() {\n    std::vector<int> v = {1, 2, 3, 4, 5};\n    std::vector<int> result(v.size());\n\n    // Square each element\n    std::transform(v.begin(), v.end(), result.begin(),\n        [](int x) { return x * x; });\n    std::cout << \"Squares: \";\n    for (int x : result) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    // Transform in-place\n    std::transform(v.begin(), v.end(), v.begin(),\n        [](int x) { return x * 2; });\n    std::cout << \"Doubled: \";\n    for (int x : v) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    // Binary transform - add two vectors\n    std::vector<int> v1 = {1, 2, 3};\n    std::vector<int> v2 = {4, 5, 6};\n    std::vector<int> sum(v1.size());\n    std::transform(v1.begin(), v1.end(), v2.begin(), sum.begin(),\n        [](int a, int b) { return a + b; });\n    std::cout << \"Sum of vectors: \";\n    for (int x : sum) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    // Convert string to uppercase\n    std::string str = \"hello world\";\n    std::transform(str.begin(), str.end(), str.begin(), ::toupper);\n    std::cout << \"Uppercase: \" << str << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "stl-remove",
    "category": "STL",
    "description": "std::remove and std::remove_if with erase idiom",
    "snippet": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    // Remove specific value (erase-remove idiom)\n    std::vector<int> v1 = {1, 2, 3, 2, 4, 2, 5};\n    std::cout << \"Original: \";\n    for (int x : v1) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    // std::remove doesn't actually remove, it moves elements\n    auto new_end = std::remove(v1.begin(), v1.end(), 2);\n    v1.erase(new_end, v1.end());\n    std::cout << \"After remove 2: \";\n    for (int x : v1) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    // Remove with predicate (remove even numbers)\n    std::vector<int> v2 = {1, 2, 3, 4, 5, 6, 7, 8};\n    v2.erase(\n        std::remove_if(v2.begin(), v2.end(), [](int x) { return x % 2 == 0; }),\n        v2.end()\n    );\n    std::cout << \"After remove evens: \";\n    for (int x : v2) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    // Remove elements greater than 5\n    std::vector<int> v3 = {1, 8, 3, 9, 2, 7, 4};\n    v3.erase(\n        std::remove_if(v3.begin(), v3.end(), [](int x) { return x > 5; }),\n        v3.end()\n    );\n    std::cout << \"After remove > 5: \";\n    for (int x : v3) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "stl-sort-variations",
    "category": "STL",
    "description": "std::sort, stable_sort, partial_sort, and nth_element",
    "snippet": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    // std::sort - regular sort (not stable)\n    std::vector<int> v1 = {5, 2, 8, 1, 9, 3};\n    std::sort(v1.begin(), v1.end());\n    std::cout << \"Sorted: \";\n    for (int x : v1) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    // Sort in descending order\n    std::vector<int> v2 = {5, 2, 8, 1, 9, 3};\n    std::sort(v2.begin(), v2.end(), std::greater<int>());\n    std::cout << \"Descending: \";\n    for (int x : v2) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    // std::stable_sort - preserves relative order of equal elements\n    std::vector<int> v3 = {5, 2, 8, 1, 9, 3};\n    std::stable_sort(v3.begin(), v3.end());\n\n    // std::partial_sort - sort first N elements\n    std::vector<int> v4 = {5, 2, 8, 1, 9, 3, 7, 4};\n    std::partial_sort(v4.begin(), v4.begin() + 3, v4.end());\n    std::cout << \"Partial sort (first 3): \";\n    for (int x : v4) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    // std::nth_element - find nth smallest element\n    std::vector<int> v5 = {5, 2, 8, 1, 9, 3, 7, 4};\n    std::nth_element(v5.begin(), v5.begin() + 3, v5.end());\n    std::cout << \"4th smallest element: \" << v5[3] << std::endl;\n\n    // is_sorted - check if sorted\n    bool sorted = std::is_sorted(v1.begin(), v1.end());\n    std::cout << \"Is v1 sorted: \" << (sorted ? \"yes\" : \"no\") << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "stl-minmax",
    "category": "STL",
    "description": "std::min, max, min_element, max_element, and minmax",
    "snippet": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> v = {5, 2, 8, 1, 9, 3};\n\n    // std::min and std::max for two values\n    int a = 10, b = 20;\n    std::cout << \"Min: \" << std::min(a, b) << std::endl;\n    std::cout << \"Max: \" << std::max(a, b) << std::endl;\n\n    // std::min_element and std::max_element\n    auto min_it = std::min_element(v.begin(), v.end());\n    auto max_it = std::max_element(v.begin(), v.end());\n    std::cout << \"Min element: \" << *min_it << \" at index \" << (min_it - v.begin()) << std::endl;\n    std::cout << \"Max element: \" << *max_it << \" at index \" << (max_it - v.begin()) << std::endl;\n\n    // std::minmax - get both min and max\n    auto [min_val, max_val] = std::minmax({5, 2, 8, 1, 9});\n    std::cout << \"Minmax: \" << min_val << \", \" << max_val << std::endl;\n\n    // std::minmax_element - get both iterators\n    auto [min_iter, max_iter] = std::minmax_element(v.begin(), v.end());\n    std::cout << \"Min: \" << *min_iter << \", Max: \" << *max_iter << std::endl;\n\n    // With custom comparator\n    auto abs_max = std::max_element(v.begin(), v.end(),\n        [](int a, int b) { return std::abs(a) < std::abs(b); });\n    std::cout << \"Max by absolute value: \" << *abs_max << std::endl;\n\n    // Clamp value to range\n    int value = 15;\n    int clamped = std::clamp(value, 5, 10);\n    std::cout << \"Clamped \" << value << \" to [5,10]: \" << clamped << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "stl-predicates",
    "category": "STL",
    "description": "std::all_of, any_of, none_of for testing predicates",
    "snippet": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> v1 = {2, 4, 6, 8, 10};\n    std::vector<int> v2 = {1, 3, 5, 7, 9};\n    std::vector<int> v3 = {1, 2, 3, 4, 5};\n\n    // std::all_of - check if all elements satisfy condition\n    bool all_even = std::all_of(v1.begin(), v1.end(), [](int x) { return x % 2 == 0; });\n    std::cout << \"All even in v1: \" << (all_even ? \"yes\" : \"no\") << std::endl;\n\n    // std::any_of - check if any element satisfies condition\n    bool any_even = std::any_of(v2.begin(), v2.end(), [](int x) { return x % 2 == 0; });\n    std::cout << \"Any even in v2: \" << (any_even ? \"yes\" : \"no\") << std::endl;\n\n    // std::none_of - check if no elements satisfy condition\n    bool none_negative = std::none_of(v3.begin(), v3.end(), [](int x) { return x < 0; });\n    std::cout << \"None negative in v3: \" << (none_negative ? \"yes\" : \"no\") << std::endl;\n\n    // Practical examples\n    std::vector<int> ages = {25, 30, 35, 28, 32};\n\n    bool all_adults = std::all_of(ages.begin(), ages.end(), [](int age) { return age >= 18; });\n    std::cout << \"All adults: \" << (all_adults ? \"yes\" : \"no\") << std::endl;\n\n    bool any_senior = std::any_of(ages.begin(), ages.end(), [](int age) { return age >= 65; });\n    std::cout << \"Any senior: \" << (any_senior ? \"yes\" : \"no\") << std::endl;\n\n    bool none_minor = std::none_of(ages.begin(), ages.end(), [](int age) { return age < 18; });\n    std::cout << \"None minor: \" << (none_minor ? \"yes\" : \"no\") << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "stl-unique",
    "category": "STL",
    "description": "std::unique to remove consecutive duplicates",
    "snippet": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    // Remove consecutive duplicates\n    std::vector<int> v1 = {1, 1, 2, 2, 2, 3, 3, 4, 5, 5};\n    std::cout << \"Original: \";\n    for (int x : v1) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    auto new_end = std::unique(v1.begin(), v1.end());\n    v1.erase(new_end, v1.end());\n    std::cout << \"After unique: \";\n    for (int x : v1) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    // Remove all duplicates (sort first, then unique)\n    std::vector<int> v2 = {3, 1, 2, 1, 3, 2, 4, 3, 2};\n    std::sort(v2.begin(), v2.end());\n    v2.erase(std::unique(v2.begin(), v2.end()), v2.end());\n    std::cout << \"All duplicates removed: \";\n    for (int x : v2) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    // Unique with custom comparator\n    std::vector<int> v3 = {1, -1, 2, -2, 3, 3, 4};\n    auto abs_end = std::unique(v3.begin(), v3.end(),\n        [](int a, int b) { return std::abs(a) == std::abs(b); });\n    v3.erase(abs_end, v3.end());\n    std::cout << \"Unique by absolute value: \";\n    for (int x : v3) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "stl-partition",
    "category": "STL",
    "description": "std::partition and related partitioning algorithms",
    "snippet": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    // std::partition - rearrange elements by predicate\n    std::vector<int> v1 = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    auto partition_point = std::partition(v1.begin(), v1.end(),\n        [](int x) { return x % 2 == 0; });\n\n    std::cout << \"Partitioned (evens first): \";\n    for (int x : v1) std::cout << x << \" \";\n    std::cout << std::endl;\n    std::cout << \"Partition point at index: \" << (partition_point - v1.begin()) << std::endl;\n\n    // std::stable_partition - preserve relative order\n    std::vector<int> v2 = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    std::stable_partition(v2.begin(), v2.end(), [](int x) { return x % 2 == 0; });\n    std::cout << \"Stable partition (evens first): \";\n    for (int x : v2) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    // std::is_partitioned - check if already partitioned\n    bool partitioned = std::is_partitioned(v1.begin(), v1.end(),\n        [](int x) { return x % 2 == 0; });\n    std::cout << \"Is partitioned: \" << (partitioned ? \"yes\" : \"no\") << std::endl;\n\n    // std::partition_point - find partition point in partitioned range\n    std::vector<int> v3 = {2, 4, 6, 8, 1, 3, 5, 7};\n    auto pp = std::partition_point(v3.begin(), v3.end(),\n        [](int x) { return x % 2 == 0; });\n    std::cout << \"Partition point value: \" << *pp << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "stl-copy-replace",
    "category": "STL",
    "description": "std::copy_if, replace_if, and fill operations",
    "snippet": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> src = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n\n    // std::copy - copy all elements\n    std::vector<int> dest1(src.size());\n    std::copy(src.begin(), src.end(), dest1.begin());\n    std::cout << \"Copied: \";\n    for (int x : dest1) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    // std::copy_if - copy only elements matching predicate\n    std::vector<int> evens;\n    std::copy_if(src.begin(), src.end(), std::back_inserter(evens),\n        [](int x) { return x % 2 == 0; });\n    std::cout << \"Evens: \";\n    for (int x : evens) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    // std::replace - replace value\n    std::vector<int> v1 = {1, 2, 3, 2, 4, 2, 5};\n    std::replace(v1.begin(), v1.end(), 2, 99);\n    std::cout << \"Replace 2 with 99: \";\n    for (int x : v1) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    // std::replace_if - replace with predicate\n    std::vector<int> v2 = {1, 2, 3, 4, 5, 6, 7, 8};\n    std::replace_if(v2.begin(), v2.end(),\n        [](int x) { return x % 2 == 0; }, 0);\n    std::cout << \"Replace evens with 0: \";\n    for (int x : v2) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    // std::fill - fill with value\n    std::vector<int> v3(10);\n    std::fill(v3.begin(), v3.end(), 42);\n    std::cout << \"Filled with 42: \";\n    for (int x : v3) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    // std::fill_n - fill first n elements\n    std::vector<int> v4(10, 0);\n    std::fill_n(v4.begin(), 5, 99);\n    std::cout << \"First 5 filled with 99: \";\n    for (int x : v4) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    return 0;\n}"
  },
  {
    "name": "stl-for-each",
    "category": "STL",
    "description": "std::for_each to apply function to each element",
    "snippet": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nint main() {\n    std::vector<int> v = {1, 2, 3, 4, 5};\n\n    // std::for_each - apply function to each element\n    std::cout << \"Print each: \";\n    std::for_each(v.begin(), v.end(), [](int x) {\n        std::cout << x << \" \";\n    });\n    std::cout << std::endl;\n\n    // Modify elements with for_each\n    std::for_each(v.begin(), v.end(), [](int& x) {\n        x *= 2;\n    });\n    std::cout << \"After doubling: \";\n    for (int x : v) std::cout << x << \" \";\n    std::cout << std::endl;\n\n    // for_each with stateful lambda\n    int sum = 0;\n    std::for_each(v.begin(), v.end(), [&sum](int x) {\n        sum += x;\n    });\n    std::cout << \"Sum: \" << sum << std::endl;\n\n    // for_each with custom function object\n    struct Counter {\n        int count = 0;\n        void operator()(int x) {\n            if (x % 2 == 0) count++;\n        }\n    };\n    Counter c = std::for_each(v.begin(), v.end(), Counter());\n    std::cout << \"Even count: \" << c.count << std::endl;\n\n    // Print with index\n    int index = 0;\n    std::for_each(v.begin(), v.end(), [&index](int x) {\n        std::cout << \"v[\" << index++ << \"] = \" << x << std::endl;\n    });\n\n    return 0;\n}"
  }
]